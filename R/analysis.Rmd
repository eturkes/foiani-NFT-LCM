---
title: "Foiani NFT LCM Analysis"
knit: (function(inputFile, encoding) {
  rmarkdown::render(
    inputFile,
    encoding = encoding,
    output_file = file.path("..", "results", "analysis.html")
  )})
---

# Data Cleaning and Prep

In this section, the raw data is read into R and manipulated as necessary to create a `SummarizedExperiment` object for use with the `DEP` package.

```{r}
#    This file is part of foiani-NFT-LCM.
#    Copyright (C) 2023  Emir Turkes, Martha Foiani, UK DRI at UCL
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

# Best way to load a bunch of packages without tons of messages being produced.
# -----------------------------------------------------------------------------
packages <- c("DEP", "SummarizedExperiment", "plotly")
invisible(suppressPackageStartupMessages(lapply(packages, FUN = library, character.only = TRUE)))
# -----------------------------------------------------------------------------

knitr::opts_chunk$set(dpi = 300, fig.width = 12, fig.height = 8) # Produce high-quality images with better sizes.

data <- read.delim(file.path("..", "data", "report.pg_matrix.tsv")) # Read in data.

# Use some regex magic to tidy up sample names.
# ---------------------------------------------
colnames(data) <- sub("^.*?([0-9]+_[^_]+_[0-9]+_[^_]+).*", replacement = "\\1", x = colnames(data))
colnames(data) <- c(colnames(data)[1:5], paste0("Donor", colnames(data)[6:60]))
colnames(data) <- c(
  colnames(data)[1:5], sub("(.*_){1}(\\d+)_.+", replacement = "\\1TechRep\\2", colnames(data)[6:60])
)
# ---------------------------------------------

# Remove proteins that do not have a gene annotation.
# ---------------------------------------------------
remove <- which(data$Genes == "")
if (length(remove > 0)) { # Need to check that "remove" is non-empty.
  data <- data[-remove, ]
}
# ---------------------------------------------------

# Adds "name" and "id" columns to end of the data frame that contain one gene and protein name per row, as
# opposed to several semicolon delimited entries as seen in the "Genes" and "Protein.Ids" columns.
# --------------------------------------------------------------------------------------------------------
data <- make_unique(data, names = "Genes", ids = "Protein.Ids")
# --------------------------------------------------------------------------------------------------------

# Create a data frame for metadata.
# "label", "condition", and "replicate" are required for the DEP package.
# -----------------------------------------------------------------------
experimental_design <- data.frame(
  label = colnames(data)[6:60],
  condition = sub("^[^_]*_([^_]*).*", replacement = "\\1", colnames(data)[6:60]),
  techrep = sub(".*_", replacement = "", colnames(data)[6:60]),
  donor = sub("_.*", replacement = "", colnames(data)[6:60])
)
experimental_design$replicate <- paste(experimental_design$donor, experimental_design$techrep, sep = "_")
# -----------------------------------------------------------------------

# Create SummarizedExperiment object for use with DEP.
# ----------------------------------------------------
data <- make_se(data, columns = 6:60, expdesign = experimental_design)
data_bak <- data # Make a copy of unprocessed data for later.
# ----------------------------------------------------
```

# Preprocessing

Basic QC visualisations are shown here and the data is normalised and imputed, using standard methods.

```{r}
hist(assay(data), n = 100) # Visualise data distribution.

# Various plotting methods to assess missing values.
# --------------------------------------------------
plot_numbers(data)
plot_frequency(data)
plot_detect(data)
plot_missval(data)
# --------------------------------------------------

# Must remove samples where no proteins at all were detected.
# -----------------------------------------------------------
remove <- which(colSums(assay(data), na.rm = TRUE) == 0)
if (length(remove > 0)) {
  data <- data[ , -remove]
}
# -----------------------------------------------------------

# Normalise data using a variance stabilising transformation (VSN).
# -----------------------------------------------------------------
orig <- data # Make a copy of the pre-normalised data for plotting later.
data <- normalize_vsn(data)
meanSdPlot(data)
plot_normalization(orig)
plot_normalization(data)
# -----------------------------------------------------------------

# Impute data using the k-nearest neighbors algorithmn (KNN).
# -----------------------------------------------------------
orig <- data
data <- impute(data, fun = "knn", colmax = 100)
plot_imputation(orig, data)
# -----------------------------------------------------------

rm(orig) # Remove temporary objects.
```

# PCA

Create PCA plots for the data.
The plots have interactive features when moused-over.

```{r, dpi = 96}
# Manually perform PCA for more flexible plotting.
# ------------------------------------------------
pca <- prcomp(t(assay(data))) # Transpose because PCA assumes rows are observations and columns are variables.
df <- as.data.frame(predict(pca)[ , 1:2]) # Extract the first two PCs.
df$Condition <- data$condition
df$Donor <- data$donor
df$Sample <- colnames(data)
summary <- summary(pca)$importance # Extract variance explained.
# ------------------------------------------------

# Plot PCA using ggplot2 rather than DEP's built-in function.
# ggplots are also wrapped in ggplotly for interactivity.
# -----------------------------------------------------------
ggplotly(
  ggplot(df, aes(PC1, PC2, color = Sample, text = paste("Donor:", Donor))) +
    geom_point(aes(shape = Condition), size = 2, stroke = 1) +
    labs(
      x = paste0("PC1: ", round(summary[2, 1] * 100, digits = 1), "% of Variance Explained"),
      y = paste0("PC2: ", round(summary[2, 2] * 100, digits = 1), "% of Variance Explained")
    ) +
    theme_bw()
)
ggplotly(
  ggplot(df, aes(PC1, PC2, color = Donor, text = paste("Sample:", Sample))) +
    geom_point(aes(shape = Condition), size = 2, stroke = 1) +
    labs(
      x = paste0("PC1: ", round(summary[2, 1] * 100, digits = 1), "% of Variance Explained"),
      y = paste0("PC2: ", round(summary[2, 2] * 100, digits = 1), "% of Variance Explained")
    ) +
    theme_bw()
)
# -----------------------------------------------------------
```

# Subsetting

Subset the data to those samples that group together on the basis of missing fewer values.

```{r}
keep <- rownames(df[which(df$PC1 < 0 & df$PC2 > 0), ]) # Top left of PCA seems to have highest quality results.
data_bak_sub <- data_bak[ , keep] # Use unprocessed copy to visualise missing values.

plot_numbers(data_bak_sub)

remove <- which(data_bak_sub$donor == "Donor9") # Remove Donor9 because there are no good tangle-neg. samples.
data_bak_sub <- data_bak_sub[ , -remove]

plot_numbers(data_bak_sub)

# Apply subsetting to the processed dataset.
# ------------------------------------------
data <- data[ , keep]
data <- data[ , -remove]
# ------------------------------------------
```

# PCA

Create more PCA plots after subsetting.

```{r, dpi = 96}
# Manually perform PCA for more flexible plotting.
# ------------------------------------------------
pca <- prcomp(t(assay(data))) # Transpose because PCA assumes rows are observations and columns are variables.
df <- as.data.frame(predict(pca)[ , 1:2]) # Extract the first two PCs.
df$Condition <- data$condition
df$Donor <- data$donor
df$Sample <- colnames(data)
summary <- summary(pca)$importance # Extract variance explained.
# ------------------------------------------------

# Plot PCA using ggplot2 rather than DEP's built-in function.
# ggplots are also wrapped in ggplotly for interactivity.
# -----------------------------------------------------------
ggplotly(
  ggplot(df, aes(PC1, PC2, color = Sample, text = paste("Donor:", Donor))) +
    geom_point(aes(shape = Condition), size = 2, stroke = 1) +
    labs(
      x = paste0("PC1: ", round(summary[2, 1] * 100, digits = 1), "% of Variance Explained"),
      y = paste0("PC2: ", round(summary[2, 2] * 100, digits = 1), "% of Variance Explained")
    ) +
    theme_bw()
)
ggplotly(
  ggplot(df, aes(PC1, PC2, color = Donor, text = paste("Sample:", Sample))) +
    geom_point(aes(shape = Condition), size = 2, stroke = 1) +
    labs(
      x = paste0("PC1: ", round(summary[2, 1] * 100, digits = 1), "% of Variance Explained"),
      y = paste0("PC2: ", round(summary[2, 2] * 100, digits = 1), "% of Variance Explained")
    ) +
    theme_bw()
)
# -----------------------------------------------------------
```

# Reprocessing

We start with the unprocessed data again, this time with the low-quality samples removed in order to achieve better proprocessing.

```{r}
data <- data_bak_sub # Make the main data object the unprocessed version.

hist(assay(data), n = 100) # Visualise data distribution.

# Various plotting methods to assess missing values.
# --------------------------------------------------
plot_numbers(data)
plot_frequency(data)
plot_detect(data)
plot_missval(data)
# --------------------------------------------------

# Must remove samples where no proteins at all were detected.
# -----------------------------------------------------------
remove <- which(colSums(assay(data), na.rm = TRUE) == 0)
if (length(remove > 0)) {
  data <- data[ , -remove]
}
# -----------------------------------------------------------

# Normalise data using a variance stabilising transformation (VSN).
# -----------------------------------------------------------------
orig <- data # Make a copy of the pre-normalised data for plotting later.
data <- normalize_vsn(data)
meanSdPlot(data)
plot_normalization(orig)
plot_normalization(data)
# -----------------------------------------------------------------

# Impute data using the k-nearest neighbors algorithmn (KNN).
# -----------------------------------------------------------
orig <- data
data <- impute(data, fun = "knn", colmax = 100)
plot_imputation(orig, data)
# -----------------------------------------------------------

rm(orig) # Remove temporary objects.
```
# PCA

Create more PCA plots with the reprocessed data.

```{r, dpi = 96}
# Manually perform PCA for more flexible plotting.
# ------------------------------------------------
pca <- prcomp(t(assay(data))) # Transpose because PCA assumes rows are observations and columns are variables.
df <- as.data.frame(predict(pca)[ , 1:2]) # Extract the first two PCs.
df$Condition <- data$condition
df$Donor <- data$donor
df$Sample <- colnames(data)
summary <- summary(pca)$importance # Extract variance explained.
# ------------------------------------------------

# Plot PCA using ggplot2 rather than DEP's built-in function.
# ggplots are also wrapped in ggplotly for interactivity.
# -----------------------------------------------------------
ggplotly(
  ggplot(df, aes(PC1, PC2, color = Sample, text = paste("Donor:", Donor))) +
    geom_point(aes(shape = Condition), size = 2, stroke = 1) +
    labs(
      x = paste0("PC1: ", round(summary[2, 1] * 100, digits = 1), "% of Variance Explained"),
      y = paste0("PC2: ", round(summary[2, 2] * 100, digits = 1), "% of Variance Explained")
    ) +
    theme_bw()
)
ggplotly(
  ggplot(df, aes(PC1, PC2, color = Donor, text = paste("Sample:", Sample))) +
    geom_point(aes(shape = Condition), size = 2, stroke = 1) +
    labs(
      x = paste0("PC1: ", round(summary[2, 1] * 100, digits = 1), "% of Variance Explained"),
      y = paste0("PC2: ", round(summary[2, 2] * 100, digits = 1), "% of Variance Explained")
    ) +
    theme_bw()
)
# -----------------------------------------------------------
```
